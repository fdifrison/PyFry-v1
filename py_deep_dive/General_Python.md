<h1>General Python</h1>

TOC

- [PEP8 - Naming conventions](#pep8---naming-conventions)
- [Everything is an Object](#everything-is-an-object)
- [Variables and Memory](#variables-and-memory)
  - [- `id` function](#--id-function)
  - [- Reference Counting](#--reference-counting)
  - [- Shared Reference](#--shared-reference)
  - [- Garbage Collection](#--garbage-collection)
  - [- Object Mutability](#--object-mutability)
  - [- Variable Equality](#--variable-equality)
- [Built-in methods](#built-in-methods)
  - [- `isinstance(object, class)`](#--isinstanceobject-class)
- [Loops](#loops)
  - [- While loop](#--while-loop)
  - [- Try statement](#--try-statement)
    - [COMMON EXCEPTION](#common-exception)
- [Strings](#strings)
    - [COMMON METHODS](#common-methods)
- [Classes](#classes)
  - [- Getters and Setters](#--getters-and-setters)
  - [- Overload methods](#--overload-methods)
    - [`str` method](#str-method)
    - [`repr` method](#repr-method)
    - [`eq` method](#eq-method)
- [Python optimizations](#python-optimizations)
  - [Interning](#interning)
  - [Peephole](#peephole)

# PEP8 - Naming conventions

- `packages`: short lowercase and without underscore es. `utilities`
- `modules`: short lowercase and with underscore es. `db_utils`
- `classes`: first letter of each word are uppercase, no spaces and no underscore es. `MyClass`
- `functions` lowercase and with underscore es. `open_account`
- `variables` lowercase and with underscore es. `account_id`
- `constants` all uppercase with underscore es `MIN_VAL`

# Everything is an Object

In python everything is an object. Functions for example, inherit from the built-in function class; the same happen for classes which inherit from class function. This implies that every objects has a memory address (yes, even function and classes). In the same way every object che by assigned to a variable, passed as argument to a function or returned by a function. We can look at the object type of any variable with the `type` built-in function.

# Variables and Memory

When a variable is created, what python is doing under the hood is to link the variable name to the memory slot (slots) which contains the element assign to the variable. Therefore the name is nothing more than a reference to the memory slot.

## - `id` function

`id`is the function that returns the memory address of a variable in base-10 ( can be converted with `hex` to see the hexadecimal representation).

## - Reference Counting

Reference counting is a process carried out by the python memory manager internally. Each time we create a new variable, we are creating a reference to a memory slot. If we create a new variable that is equal to an existing one, we are adding a reference to the same memory slot (which now has a reference count equal to two).

```py
my_var = 10 # my_var is pointing to the memory slot id(my_var)

other_var = my_var # other var is pointing to the same memory slot of my_var
# at this point, the ref count of id(my_var) is equal to 2

import sys
sys.getrefcount(my_var) 
# return the ref count of the variable + 1 far the call of sys itself

import ctypes
ctypes.c_long.from_address(id(my_var)).value 
# is a lower level way to find the ref count of a memory slot
```

## - Shared Reference

```py
a = 10
b = a
# b is not copying the content of a, it is pointing to the same memory address

a = 10
b = 10
# since the number 10 is immutable, both a and b are pointing to the same memory address

a = [1,2,3]
b = a
b.append(4)
# now both b and a are equal to [1,2,3,4] since a list is mutable object and appending an element modify only its internal state with the same memory address

a = [1,2,3]
b = [1,2,3]
# in this case python doesn't create shared references, so a and b are pointing to different objects, this to prevent that modifying b affects also a
```

N.b. There will be always a shared reference to `None` object, created automatically by python.

## - Garbage Collection

It is the way python use to avoid memory leaks such that generated by circular references (objects pointing one to the other). Garbage collection can be controlled using the `gc` method. It can be turned off (only if we are super-sure that there are not circular reference in the code, in order to improve performance). The gc runs periodically on its own but can also be called manually to program a specific cleanup of the code.

## - Object Mutability

Changing the data inside an object is called `modifying the internal state` since the memory address is not changed but only its content (es. appending an element to a list). So we can distinguish between `Mutable` and `Immutable` object depending on the possibility of changing the internal state.

`Immutable objects:`

- Numbers
- Strings
- Tuples (if contains mutable elements, es. lists, those remain mutable)
- Frozen Sets
- User_Defined Classes (if so defined)

`Mutable objects:`

- Lists
- Sets
- Dictionaries
- User_Defined Classes (if so defined)

Care must be taken when we talk about immutability of an object that is given to a function as an argument. We have to distinguish between the `module scope` and the `function scope`.
When we pass an object to a function we are in reality passing the `reference` of the object itself. So if we are passing to a function an immutable object, say a string, at the beginning both the module scope and the function scope point to the same memory reference, but as soon as the function modify the string (es. concatenating another string), then a new object with a new reference is created. If the object is mutable, say a list, and the function modify the list (es. appending an element), then python doesn't create a new object but simply modify the internal state of the existing memory reference

```py
# IMMUTABLE
def process(s):
  # s has still the same memory reference as my_string
  s = 'hello' + s
  # now s has been modified, and since it was an immutable object, a new object with a new reference is created.
  return s

my_string = 'world'
process(my_string) 

# MUTABLE
def process(lst):
  # lst has the same memory reference as my_list
  lst.append(5)
  # since lst is a mutable object, only the internal state is changed but the memory reference is still the same.

my_list = 'world'
process(my_list) 

```

## - Variable Equality

There are two ways to verify the equality of two variables in python: the `is` and the `==` operators, respectively the identity and equality operators. While the identity operator compares the memory reference of two objects, the equality operator compares their internal state (data). Their negation are `is not` and `!=`.

```py
a = 10
b = a

a is b # True since the memory address is the same (int are immutable objects)
a == b # True

a = 500
b = 500

a is b # False, preloaded integers are in the range [-5, 256] see Interning
a == b # True



a = [1,2,3]
b = [1,2,3]

a is b # False, different memory address
a == b # True


a = 'hello'
b = 'hello'

a is b # True, but not always!
a == b # True

a = 10.0
b = 10

a is b # False, float and int are different objects
a == b # True, python recognize the have the same value
```

# Built-in methods

## - `isinstance(object, class)`

Return `True` if an object is an instance of a particular class, `False` otherwise.

# Loops

## - While loop

to generate an infinite loop:

```py
while True:
    print('Infinite Loop')
```

`else` statement is executed after a while loop only if it terminates without a `break`

`continue` is used to interrupt the execution of the current iteration are restart the loop with the next iteration. Only `finally` statement is executed after a continue statement.

## - Try statement

test a code block.

`except` is used to captures errors and handle exceptions

`finally` is a code block that is always executed, whether an exception or a break are invoked

### COMMON EXCEPTION

- ZeroDivisionError

-

# Strings

### COMMON METHODS

- isalpha() -> check if is alphanumeric
- isprintable() -> check if is printable

# Classes

`__init__` is the default method that is called after the class object is created. The first argument is always `self`, i.e. the instance of the object created calling the class object.

```py
class Rectangle:
  def __init__(self, width, height):
    self.width = width
    self.height = height

r1 = Rectangle(10,20)
# r1 is a instance of the class Rectangle, referred as `self` inside the class constructor    

```

## - Getters and Setters

Getter and setter methods are implemented to impose some dynamics in the class structure. In python there are no private attributes (even if we can specify to the reader that a variable is private beginning its name with _). Setter and getter methods impose to the user a constrain

## - Overload methods

There are some special methods that are built into the `class` constructor and are passed automatically to any instance of the class even if they are not defined explicitly. For example if we call the python method `str` on an instance of the class we will receive a standard output specifying the memory address of the instance. Unless we overwrite or `overload` this method explicitly inside the class definition.

### `str` method

```py
class Rectangle:
  def __init__(self, width, height):
    self.width = width
    self.height = height

  def __str__(self):
    return f'Rectangle: width:{self.width}, height:{self.height}'

r1 = Rectangle(10,20)

str(r1) # will print what inside the __str__ method
# if __str__ is not defined than the output will be:
# <__main__.Rectangle object at "some memory address">

```

### `repr` method

It is similar to `__str__` method but its use is more developer-oriented. The repr method should return the string representation of the class instance called

```py
class Rectangle:
  def __init__(self, width, height):
    self.width = width
    self.height = height

  def __repr__(self):
    return f'Rectangle({self.width}, height:{self.height})'

r1 = Rectangle(10,20)

repr(r1) # will print what inside the __repr__ method that is exactly Rectangle(10,20), how the object r1 has been created in the first place

```

### `eq` method

Is the method needed to compare two objects generated by the same class with the `==` operator.

# Python optimizations

## Interning

Python at startup automatically pre-loads (caches) a global list of integer in the range [-5, 256], so these integers have a fixed memory reference. Since these numbers show up often, avoid to reference these each time they appear results in an optimization. A number outside this range will require a new memory reference, and that's why:

```py
a = 500
b = 500
a is b # will return False
```

The caches integers are called `Singletons`, basically classes that can be instantiated only once.

The same might happen with some strings; python can interning some string (that follow certain rules, letters and numbers concatenated with underscores) in order to speed up the equality (if a string in interned than i can use the `is` operator, otherwise i have to use the `==` character by character). We can force python to interning strings with the sys module:

```py
'''
usually is something we don't need, unless for example we are working with a large ste of string for NPL and we need to tokenize some words that are reaped often. In this case it can be a useful optimization, since if a string is interned it becomes a Singleton and can be compared with the mush faster 'is' operator.
'''
import sys

a = sys.intern('this will be interned')
```

## Peephole

Is an optimization that occur at compile time (so it is repeated each time the script is launched). For example we can have `Constant expression` like numeric calculation thata are better read as the operation rather than the results:

```py
minute_in_day = 60 * 24 # 1440
```



